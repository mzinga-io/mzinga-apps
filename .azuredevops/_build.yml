parameters:
  - name: dockerRegistryServiceConnection
    default: "Newesis Srl Production"
  - name: azureSubscription
    default: "Newesis - Corporate Services"
  - name: latestTag
    default: latest
  - name: canPush
  - name: payloadPublicServerUrl
    default: https://admin-mzinga-app.mzinga.io
  - name: testNamespace
    default: mzinga-app
  - name: imageSuffix
    default: ""

jobs:
  - job: Set_Version_And_Images_Names
    steps:
      - checkout: self
        fetchDepth: 0
        retryCountOnTaskFailure: 3
        fetchTags: true
        clean: true
        persistCredentials: true

      - template: gitversion.template.yml@common-templates

      - script: |
          echo "Set build number and 'tag' variable"
          echo "##vso[build.addbuildtag]mzinga-$(GitVersion.FullSemVer)"
        displayName: Set tag and build number

      - script: |
          echo "##vso[task.setvariable variable=tag;isoutput=true;]$(GitVersion.FullSemVer)"
          echo "##[debug][task.setvariable variable=tag;isoutput=true;]$(GitVersion.FullSemVer)"
        displayName: Set version variable
        name: setVersion

      - script: |
          apiImageName="mzinga/payload/api$IMAGE_SUFFIX"
          backofficeImageName="mzinga/payload/backoffice$IMAGE_SUFFIX"
          echo "##vso[task.setvariable variable=apiImageName;isoutput=true;]$apiImageName"
          echo "##vso[task.setvariable variable=backofficeImageName;isoutput=true;]$backofficeImageName"

          echo "##[debug][task.setvariable variable=apiImageName;isoutput=true;]$apiImageName"
          echo "##[debug][task.setvariable variable=backofficeImageName;isoutput=true;]$backofficeImageName"
        env:
          IMAGE_SUFFIX: ${{ parameters.imageSuffix }}
        displayName: Set images names
        name: setImagesNames

  - job: Build_And_Push_Backoffice
    dependsOn: Set_Version_And_Images_Names
    variables:
      version: $[ dependencies.Set_Version_And_Images_Names.outputs['setVersion.tag'] ]
      backofficeImageName: $[ dependencies.Set_Version_And_Images_Names.outputs['setImagesNames.backofficeImageName'] ]
    steps:
      - task: NodeTool@0.245.1
        displayName: "Install Node.js"
        inputs:
          versionSpec: "22.x"

      - bash: |
          npm version --no-git-tag-version --new-version $VERSION
        env:
          VERSION: $(version)
        displayName: Update package.json with new version

      - script: |
          cat package.json
        displayName: Show package.json file

      - template: _build_app.yml
        parameters:
          jobId: "Build_MZinga_Backoffice"
          canPush: true
          dockerFile: "$(build.SourcesDirectory)/backoffice.Dockerfile"
          imageName: $(backofficeImageName)
          version: $(version)

  - job: Build_And_Push_API
    dependsOn: Set_Version_And_Images_Names
    variables:
      version: $[ dependencies.Set_Version_And_Images_Names.outputs['setVersion.tag'] ]
      apiImageName: $[ dependencies.Set_Version_And_Images_Names.outputs['setImagesNames.apiImageName'] ]
    steps:
      - task: NodeTool@0.245.1
        displayName: "Install Node.js"
        inputs:
          versionSpec: "22.x"

      - bash: |
          npm version --no-git-tag-version --new-version $VERSION
        env:
          VERSION: $(version)
        displayName: Update package.json with new version

      - script: |
          cat package.json
        displayName: Show package.json file

      - template: _build_app.yml
        parameters:
          jobId: "Build_MZinga_API"
          canPush: true
          dockerFile: "$(build.SourcesDirectory)/api.Dockerfile"
          imageName: $(apiImageName)
          version: $(version)

  - job: Deploy_To_K8s
    dependsOn:
      - Set_Version_And_Images_Names
      - Build_And_Push_Backoffice
      - Build_And_Push_API
    variables:
      version: $[ dependencies.Set_Version_And_Images_Names.outputs['setVersion.tag'] ]
      apiImageName: $[ dependencies.Set_Version_And_Images_Names.outputs['setImagesNames.apiImageName'] ]
      backofficeImageName: $[ dependencies.Set_Version_And_Images_Names.outputs['setImagesNames.backofficeImageName'] ]
    steps:
      - script: |
          az login --service-principal -t $(TENANT_ID) -u $(CLIENT_ID) -p $(CLIENT_SECRET)
          az account set -s $(SUBSCRIPTION_ID)
        displayName: Set Azure account

      - task: KubeloginInstaller@0
        displayName: Install Kubelogin
        inputs:
          kubeloginVersion: latest

      - task: AzureCLI@2
        displayName: "Deploy to Test Environment"
        inputs:
          azureSubscription: ${{ parameters.azureSubscription }}
          scriptType: "bash"
          scriptLocation: "inlineScript"
          inlineScript: |
            echo "Deploying to Kubernetes Cluster"
            az aks get-credentials --resource-group rg-aks-newesis-corporate-we --name aks-newesis-corporate-we --overwrite-existing --admin -f ~/.kube/config
            kubelogin convert-kubeconfig -l azurecli
            kubectl config rename-context aks-newesis-corporate-we-admin aks-newesis-corporate-we
            kubectl config use-context aks-newesis-corporate-we

            # Deploy API
            kubectl set image deployment/mzinga-api api=newesissrl.azurecr.io/$(apiImageName):$(version) -n ${{ parameters.testNamespace }}
            kubectl rollout status deployment/mzinga-api -n ${{ parameters.testNamespace }}

            # Deploy Backoffice
            kubectl set image deployment/mzinga-bo backoffice=newesissrl.azurecr.io/$(backofficeImageName):$(version) -n ${{ parameters.testNamespace }}
            kubectl rollout status deployment/mzinga-bo -n ${{ parameters.testNamespace }}

  - job: Run_Tests
    dependsOn:
      - Set_Version_And_Images_Names
      - Deploy_To_K8s
    variables:
      version: $[ dependencies.Set_Version_And_Images_Names.outputs['setVersion.tag'] ]
    steps:
      - task: Npm@1.244.3
        displayName: Install dependencies
        inputs:
          command: "install"

      - task: Npm@1.244.3
        displayName: Run coverage command
        inputs:
          command: "custom"
          customCommand: "run coverage"
        env:
          API_KEY: $(USER_API_KEY)
          PAYLOAD_PUBLIC_SERVER_URL: ${{ parameters.payloadPublicServerUrl }}
          RABBITMQ_URL: $(RABBITMQ_URL)
        retryCountOnTaskFailure: 3
        timeoutInMinutes: 10

      - task: PublishTestResults@2.247.1
        displayName: Publish test results
        inputs:
          testResultsFormat: "JUnit"
          testResultsFiles: junit.xml
          mergeTestResults: true

      - task: PublishCodeCoverageResults@2.242.1
        displayName: Publish Code Coverage Results
        inputs:
          summaryFileLocation: $(System.DefaultWorkingDirectory)/coverage/cobertura-coverage.xml

  - job: Cleanup_And_Decide
    dependsOn:
      - Run_Tests
      - Set_Version_And_Images_Names
      - Deploy_To_K8s
    condition: always()
    variables:
      version: $[ dependencies.Set_Version.outputs['setVersion.tag'] ]
      apiImageName: $[ dependencies.Set_Version_And_Images_Names.outputs['setImagesNames.apiImageName'] ]
      backofficeImageName: $[ dependencies.Set_Version_And_Images_Names.outputs['setImagesNames.backofficeImageName'] ]
      test_results: $[ dependencies.Run_Tests.result ]
    steps:
      - script: |
          az login --service-principal -t $(TENANT_ID) -u $(CLIENT_ID) -p $(CLIENT_SECRET)
          az account set -s $(SUBSCRIPTION_ID)
        displayName: Set Azure account

      - task: KubeloginInstaller@0
        displayName: Install Kubelogin
        inputs:
          kubeloginVersion: latest

      - bash: |
          echo "Cleaning up resources..."

          if [[ "$(test_results)" == "Failed" ]]; then
            echo "Tests failed. Rolling back to previous version."
            
            # Function to rollback an image
            rollback_image() {
                local acr_name=$1
                local repository=$2
                local deployment_name=$3
                local container_name=$4
                local failed_version=$5
                
                echo "Rolling back $repository..."
                
                # Get the previous version tag
                previous_version=$(echo $(az acr repository show-tags --name $acr_name --repository $repository --orderby time_desc --top 2) | jq -r ".[1]")
                
                if [ -z "$previous_version" ]; then
                    echo "Error: Could not find a previous version for $repository"
                    return 1
                fi
                
                echo "Previous version found: $previous_version"
                
                # Get AKS credentials
                az aks get-credentials --resource-group rg-aks-newesis-corporate-we --name aks-newesis-corporate-we --overwrite-existing --admin -f ~/.kube/config
                kubelogin convert-kubeconfig -l azurecli
                kubectl config rename-context aks-newesis-corporate-we-admin aks-newesis-corporate-we
                kubectl config use-context aks-newesis-corporate-we

                # Roll back the deployment
                echo "Rolling back deployment to version: $previous_version"
                kubectl set image deployment/$deployment_name $container_name=$acr_name.azurecr.io/$repository:$previous_version -n ${{ parameters.testNamespace }}
                kubectl rollout status deployment/$deployment_name -n ${{ parameters.testNamespace }}
                
                if [ $? -ne 0 ]; then
                    echo "Error: Failed to roll back deployment to version $previous_version"
                    return 1
                fi
                
                # Delete the failed version from ACR
                echo "Deleting image '$repository:$failed_version' from ACR..."
                az acr repository delete --name $acr_name --image $repository:$failed_version --yes
                
                if [ $? -ne 0 ]; then
                    echo "Warning: Failed to delete version $failed_version from ACR"
                fi
                
                echo "Successfully rolled back $repository to version $previous_version"
                return 0
            }

            # ACR name
            ACR_NAME="newesissrl"
            FAILED_VERSION=$(version)
            az acr login --name $ACR_NAME

            # Rollback API image and deployment
            rollback_image $ACR_NAME $(apiImageName) "mzinga-api" "api" "$FAILED_VERSION"

            # Rollback Backoffice image and deployment
            rollback_image $ACR_NAME $(backofficeImageName) "mzinga-bo" "backoffice" "$FAILED_VERSION"

            # Check if both rollbacks were successful
            if [ $? -eq 0 ]; then
                echo "Rollback completed successfully for both API and Backoffice"
            else
                echo "Rollback failed for one or more components"
                exit 1
            fi

            exit 1
          else
            echo "Tests passed. Keeping the new version."
          fi
        displayName: "Cleanup and decide on version"
